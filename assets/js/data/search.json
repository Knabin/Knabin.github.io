[ { "title": "C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈 Part.4 게임 서버 - 1. OT", "url": "/posts/MMORPG-%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EB%A6%AC%EC%A6%88-Part4-1/", "categories": "C++, C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈", "tags": "C++, Game Develop", "date": "2022-05-22 17:36:00 +0900", "snippet": "OT개요 게임 서버는 여러 플레이어가 같이 할 수 있게 해 주는 관제자. 그러나 관련 자료가 거의 없다… 그만큼 게임 서버 개발자에 대한 가치와 희귀성이 증가할 수밖에 없는 상황.서버 OT서버 개론 서버란? 다른 컴퓨터에서 연결이 가능하도록 항상 대기 중인 상태로 실행하는 프로그램. (물론 서버 PC 자체를 서버라고 볼 수도 있다.) 클라이언트가 영화를 찍는 거라면, 서버는 식당을 영업하는 것이다. 손님이 올 수 있도록 식당을 열고, 대기하고 있는다. 그리고 손님이 오면 안내해서 서비스를 제공한다.서버의 종류웹 서버 드물게 정보를 요청/갱신한다. 실시간 인터렉션이 필요하지 않다. 식당에서는 손님에게 먼저 접근할 수 없다. 주문 후, 손님이 떠나면, 손님의 상태를 당분간 잊고 지낸다. (stateless) 크래시 오브 클랜 등… 웹 서비스를 만드는 데 주로 사용하며, 프레임워크를 골라서 사용한다. (닷넷, spring, Node.js 등)게임 서버 요청/갱신이 잦다. 실시간 인터렉션이 필요하다. 언제라도 직원이 손님에게 접근 가능해야 한다. 손님이 식당에 머무는 동안은 손님의 상태를 보며, 최상의 서비스를 제공한다. (stateful) 스타크래프트, 와우 등… 내가 왔다 갔다 하는 행동 등 주변 유저에게 모두 보여야 한다. 즉, 이 말이 갱신 요청 횟수가 많다는 뜻이다. 이런 짓을 했다는 걸 알려 주는 패킷이 클라이언트와 서버 간 계속 오가야 한다.서버를 고를 때 고려할 점 서버는 클라이언트단과 다르게, 아무런 지식 없이 엔진만 사용해서 구현할 수 있을 만큼 간단하지 않다. 또한 게임의 장르 등… 각 게임마다 상황이 다르기 때문에 최적의 프레임워크라는 것이 존재하기 힘들다. 따라서 상황에 맞춰 여러가지 최적화를 해야 할 수밖에 없다. 고려할 대상 게임 서버 손님 한도 (몇 명까지 받을 수 있는지) 최대 동시 접속자 한 방에 들어갈 수 있는 손님의 한도 (인테리어) 게임 장르 및 채널링 직원들의 역할 (겸임 가능) 게임 로직(요리사), 네트워크(서버), DB(결제) 직원의 수 쓰레드 개수 요리사/서빙/결제 직원 비율 쓰레드 모델 주문받을 방법 (손님이 호출? 벨?) 네트워크 모델 손님이 기다릴 수 있는 시간의 한도 (패스트푸드? 고급 음식점?) 반응성 (FPS, MMORPG…) 장부 및 결제 방법 데이터베이스 MMORPG 서버는 식당 운영 멀티쓰레드(Concurrency) - 직원들을 고용하고, 운영하는 것 네트워크 - 직원들이 손님과 어떤 방식으로 대화할지 데이터베이스 - 결제 및 장부 처리를 어떤 방식으로 할지 게임 로직 - 손님들의 주문을 신속하고 맛있게 요리하는 것 서버 구조 - 식당 정책에 맞는 인테리어에 대해 고민하는 것 이 강의를 통해 게임 서버에 대한 이해도를 높이고, 클라이언트와 연동을 함으로써 그럴싸하게 동작하는 MMORPG 서버를 구현할 수 있다.환경설정구조 GameServer Client (Dummy) Server Core (핵심 기능, 쓰레드 등을 포함한 정적 라이브러리) 정적 라이브러리 vs 동적 라이브러리 정적 라이브러리 (.lib) 실제로 빌드할 때 바이너리에 라이브러리가 포함해서 나가기 때문에, 실행 파일을 만들어 두면 계속 관리할 필요가 없다. 실행할 때 라이브러리의 내용을 모두 메모리에 로드한다. 따라서 프로세스마다 할당되기 떄문에 메모리가 낭비될 가능성이 있다. 동적 라이브러리 (.dll) 실행 파일과는 별도의 파일이기 때문에, 계속 같이 포함해서 나가야 한다. 라이브러리가 메모리에 이미 존재하는 경우, 로드되는 시간과 공간을 아낄 수 있다. 단, 수행 시간이 있기 때문에 정적 라이브러리보다 느리다.설정 테스트ServerCore/pch.h#pragma once#define WIN32_LEAN_AND_MEAN // 거의 사용되지 않는 내용을 Windows 헤더에서 제외합니다.#include &quot;CorePch.h&quot;ServerCore/CorePch.h#pragma once#include &quot;Types.h&quot;#include &amp;lt;vector&amp;gt;#include &amp;lt;list&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;unordered_map&amp;gt;#include &amp;lt;unordered_set&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;void HelloWorld();ServerCore/CorePch.cpp#include &quot;pch.h&quot;#include &quot;CorePch.h&quot;void HelloWorld() { cout &amp;lt;&amp;lt; &quot;Hello Server!&quot; &amp;lt;&amp;lt; endl;}라이브러리 설정GameServer/pch.h#ifdef _DEBUG#pragma comment(lib, &quot;Debug\\\\ServerCore.lib&quot;)#else#pragma comment(lib, &quot;Release\\\\ServerCore.lib&quot;)#endifGameServer/GameServer.cpp#include &quot;pch.h&quot;#include &amp;lt;iostream&amp;gt;int main(){ HelloWorld();} Break Point 찍어서 디버깅 할 수도 있다!해당 포스트는 다음의 강의를 수강하며 개인 기록용으로 메모하였습니다. 양질의 지식을 제공해 주신 Rookiss 님께 감사드립니다.[C++과 언리얼로 만드는 MMORPG 게임 개발 시리즈] Part4: 게임 서버" }, { "title": "yaml &amp; yaml-cpp", "url": "/posts/yaml-and-yaml-cpp/", "categories": "Etc.", "tags": "YAML", "date": "2022-04-20 06:21:00 +0900", "snippet": "YAMLYAML(Yet Another Markup Language).yml, .yaml기본 문법들여쓰기 (indent)2칸(권장) 또는 4칸person: name: Nabin Kim job: developer skills: - docker - kubernetes데이터 정의 (map)key: valueapiVersion: v1kind: Podmetadata: name: echo labels: type: app배열 정의 (array)- 로 표시person: name: Nabin Kim job: Developer skills: - docker - kubernetes주석 (comment)# 로 표시# commentname: Nabin Kim # comment참/거짓true, false, yes, nostudy_hard: yesgive_up: nohello: Trueword: TRUEmanual: false숫자 표현# numberversion: 1.2# stringversion: &quot;1.2&quot;줄 바꿈마지막 줄바꿈 포함마지막 줄바꿈을 포함하는 | 지시어newlines_sample: | number one line second line last line# 이 라인 포함 (number one line\\n\\nsecond line\\n\\nlast line\\n)마지막 줄바꿈 제외마지막 줄바꿈을 제외하는 |- 지시어newlines_sample: |- number one line second line last line# 이 라인 미포함 (number one line\\n\\nsecond line\\n\\nlast line)중간 빈줄 제외중간에 들어간 빈줄을 제외하는 &amp;gt; 지시어newlines_sample: &amp;gt; number one line second line last line# 중간 공백 미포함 (number one line\\nsecond line\\nlast line\\n)주의사항key와 value의 구분 key와 value 사이에는 반드시 빈칸이 필요하다.# error (not key-value, string)key:value# ok!key: value문자열 따옴표 대부분의 문자열을 따옴표 없이 사용해도 무방하나, key 값에 :가 들어간 경우에는 반드시 따옴표가 필요하다.*, - 등이 앞에 올 때도 따옴표를 사용해야 한다.# errorwindows_drive: c:# ok!windows_drive: &quot;c:&quot;windows_drive: &#39;c:&#39;yaml-cppyaml-cppA YAML parser and emitter in C++. Contribute to jbeder/yaml-cpp development by creating an account on GitHub.Win32 빌드cmake -G &quot;Visual Studio 16 2019&quot; -A Win32 ..yaml-cpp in Qtyaml-cpp의 Qt 3rd party 사용 (qtyaml.h)yaml-cppQt Yaml support using yaml-cpp library.예제yaml filestart: - 1 - 3 - 0end: point: 1 test: - &#39;Hello&#39; - &#39;World&#39;in cpptry{ YAML::Node node = YAML::LoadFile(&quot;C:/File/Path/test.yml&quot;); auto str = node[&quot;start&quot;].as&amp;lt;QVector&amp;lt;int&amp;gt;&amp;gt;(); auto test = node[&quot;nothing&quot;]; auto str2 = node[&quot;end&quot;].as&amp;lt;QMap&amp;lt;QString, YAML::Node&amp;gt;&amp;gt;(); if (!test.IsDefined() || test.IsNull()) { // 내용이 없는 경우는 null, 아예 key 자체를 찾지 못한 경우는 undefined qDebug() &amp;lt;&amp;lt; &quot;Nothing.&quot;; } else { qDebug() &amp;lt;&amp;lt; (YAML::NodeType::value)test.Type(); } qDebug() &amp;lt;&amp;lt; str &amp;lt;&amp;lt; str2[&quot;point&quot;].as&amp;lt;int&amp;gt;() &amp;lt;&amp;lt; str2[&quot;test&quot;].as&amp;lt;QVector&amp;lt;QString&amp;gt;&amp;gt;();} catch (YAML::cast_exception &amp;amp;e){ // error 처리}output14:37:57 [DEBUG] Nothing.14:37:57 [DEBUG] QVector(1, 3, 0) 1 QVector(&quot;Hello&quot;, &quot;World&quot;)참고 사이트yaml 파일이란 무엇인가요 - 인프런 질문 &amp;amp; 답변YAML 문법 | 쿠버네티스 안내서" }, { "title": "따라 하며 배우는 노드, 리액트 시리즈 - 기본 강의 1. Node.js", "url": "/posts/%EB%94%B0%EB%9D%BC-%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%85%B8%EB%93%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%8B%9C%EB%A6%AC%EC%A6%88-%EA%B8%B0%EB%B3%B8-%EA%B0%95%EC%9D%98-1/", "categories": "JavaScript, 따라 하며 배우는 노드 리액트 시리즈", "tags": "JavaScript, Node.js", "date": "2022-04-04 00:02:00 +0900", "snippet": "소개보일러 플레이트란? 웹사이트를 만들 때, 로그인, 회원가입 등등… 통상적으로 들어가는 기능들이 존재한다. 어떠한 프로젝트를 만들 때 0부터 직접 만드는 게 아니라, 자주 쓰이는 기능을 만들어서 어디든 재사용할 수 있게 한다.Node.js와 Express.js 다운로드하기Node.js 기존 JavaScript는 브라우저에서만 동작했었다. Node.js를 통해 Chrome이나 Internet Explorer에 국한된 게 아닌, 서버 사이드(server-side)에서도 쓸 수 있게 되었다.Express.js Node.js가 자동차 엔진이라면, 그 엔진을 가지고 자동차의 바퀴도 만들고, 브레이크도 만들고… 자동차를 만드는 것이 Express.js. Node.js를 좀 더 쉽게 이용할 수 있는 프레임워크.프로젝트 설정 package.json에 express라고 추가되었음! 다운로드 할 때 –save라고 지정했는데… 이게 표시가 된다. 이 애플리케이션에서는 해당 기능을 사용하겠다, 라고 표시하는 것이다. node_modules라는 폴더 안에 다운 받을 dependency 라이브러리들이 모두 이 폴더에 있다. 여기는 수정할 일이 거의 없음.MongoDB 연동 Mongoose: 몽고디비를 편하게 쓸 수 있는 툴 다음 라인은 지워 주면 된다. MongoDB 6 버전 이상부터는 기본 값이어서 설정하지 않아도 된다.useNewUrlParser: true, useUnifiedTopology: true, useCreateIndex: true, useFindAndModify: false&amp;gt;&amp;gt; MongoParseError: options usecreateindex, usefindandmodify are not supportedMongoDB Model &amp;amp; Schema Model: Schema를 감싸 주는 역할 Schema: 상품에 관련된 글을 작성한다고 하면, 그 글을 작성한 사람이 누구인지, 작성할 때 포스트의 이름이 뭔지, 포스트 이름 타입이 뭐고, 최대 길이는 몇인지… 하나하나의 정보를 지정해 줄 수 있다.BodyParser &amp;amp; PostMan &amp;amp; 회원가입 Client - 브라우저에서 회원가입을 하려고 하면… 이 클라단에서 이메일 비밀번호 작성해서 서버에 보냄 서버에서 받을 때 필요한 것들은 Body Parser를 이용한다. 예를 들면 이름, 이메일 등을 받을 수 있음. npm install body-parser --save 현재로선 클라이언트를 만들어 둔 게 없으니 postman을 이용한다. &amp;gt; postmanNodeMon 원래대로라면 이 Node 서버를 내리고 다시 켜야 반영이 되는데, NodeMon 라이브러리를 이용하면 내리고 올리지 않아도 소스 변화를 감지해서 반영시켜 준다. npm install nodemon --save환경별 URI 설정 환경별 config를 추가하여 dev, production이 각각 다른 DB를 바라보게 한다. 또한 MongoDB URI가 외부로 노출되는 일이 없게 한다. (Git 등…)Bcrypt Bcrypt를 이용하여 패스워드를 암호화한다. npm install --save bcrypt// sava 하기 전, function을 실행함userSchema.pre(&#39;save&#39;, function(next){ var user = this; if (user.isModified(&#39;password&#39;)) { // 비밀번호를 암호화한다. // salt를 이용해서 비밀번호를 암호화하며, 이 salt를 생성해야 한다. // saltRounds는 salt가 몇 글자인지를 나타낸다. bcrypt.genSalt(saltRounds, function(err, salt) { if (err) return next(err) bcrypt.hash(user.password, salt, function(err, hash) { if (err) return next(err) user.password = hash next() }) }) } else { // 비밀번호가 아니라 다른 정보를 변경한다면 넘겨 준다. next() }}) pre 함수는 매개변수로 입력한 ‘save’ 함수가 실행되기 전, function을 실행하게끔 한다. next()는 그 다음 함수로 넘어가는 함수.로그인 기능이메일 유효성 검사, password 비교app.post(&#39;/login&#39;, (req, res) =&amp;gt; { // 요청된 이메일을 데이터베이스에 있는지 찾는다. User.findOne({ email: req.body.email }, (err, user) =&amp;gt; { if (!user) { return res.json({ loginSuccess: false, message: &quot;제공된 이메일에 해당하는 유저가 없습니다.&quot; }) } // 요청된 이메일이 데이터베이스에 있다면, 비밀번호가 맞는지 확인한다. user.comparePassword(req.body.password, (err, isMatch) =&amp;gt; { if (!isMatch) return res.json ({ loginSuccess: false, message: &quot;비밀번호가 틀렸습니다.&quot;}) // 비밀번호까지 맞다면, 토큰을 생성한다. user.generateToken((err, user) =&amp;gt; { // 후술 }) }) })}) plain text로 들어온 입력을 암호화하여 비교해 준다. 이때, bcrypt.compare()를 사용한다.userSchema.methods.comparePassword = function(plainPassword, cb) { // plainPassword 1234567 암호화된 비밀번호 $2b$10... bcrypt.compare(plainPassword, this.password, function(err, isMatch) { if (err) return cb(err); cb(null, isMatch) })}Token 생성 로그인이 성공하면 토큰을 생성한다. jsonwebtoken 라이브러리를 사용한다. &amp;gt; jsonwebtoken json web token library npm install jsonwebtoken --save jwt.sign()을 이용하여 user._id를 포함한 토큰을 생성한다. 이 토큰을 파싱하여 어떤 유저인지(user._id)를 파악할 수 있다.userSchema.methods.generateToken = function(cb) { // jsonwebtoken을 이용하여 token을 생성한다. var user = this; // user._id + &#39;secretToken&#39; = token // &#39;secretToken&#39; -&amp;gt; user._id var token = jwt.sign(user._id.toHexString(), &#39;secretToken&#39;) user.token = token user.save(function(err, user) { if (err) return cb(err) cb(null, user) })} 만들어진 토큰을 쿠키 또는 로컬 스토리지에 저장한다. 각각의 장단점이 존재하기 때문에 어디에 저장할지 선택해야 한다. 이번에는 쿠키에 저장해 본다. cookie-parser라는 라이브러리를 사용한다. npm install cookie-parser --saveapp.post(&#39;/login&#39;, (req, res) =&amp;gt; { // 요청된 이메일을 데이터베이스에 있는지 찾는다. User.findOne({ email: req.body.email }, (err, user) =&amp;gt; { if (!user) { return res.json({ loginSuccess: false, message: &quot;제공된 이메일에 해당하는 유저가 없습니다.&quot; }) } // 요청된 이메일이 데이터베이스에 있다면, 비밀번호가 맞는지 확인한다. user.comparePassword(req.body.password, (err, isMatch) =&amp;gt; { if (!isMatch) return res.json ({ loginSuccess: false, message: &quot;비밀번호가 틀렸습니다.&quot;}) // 비밀번호까지 맞다면, 토큰을 생성한다. user.generateToken((err, user) =&amp;gt; { if (err) return res.status(400).send(err); // 토큰을 저장한다. 어디에? 쿠키, 로컬 스토리지... res.cookie(&quot;x_auth&quot;, user.token) .status(200) .json({ loginSuccess: true, userId: user._id }) }) }) })})Auth 기능Auth가 필요한 이유 페이지마다 권한이 다를 수 있다. 글 쓰기 등 어떠한 페이지는 로그인이 되어 있어야 하고, 관리자만 접근할 수 있는 페이지 또한 존재할 수 있다. 따라서 페이지 이동할 때마다 로그인이 되어 있는지, 관리자 유저인지 등을 체크해야 한다. 글을 쓰거나 지울 때, 권한이 있는지 체크되어야 한다.대략적인 과정 서버에서 쿠키에 저장된 Token을 가져온다. Encoded Token을 Decode하면 user._id가 나온다. 이 id가 DB에 있다면 이 토큰은 유효하다고 서버에서 판단한다.구현 middleware: end point에서 req를 받은 다음, callback function 호출하기 전에 처리해 준다.middleware/auth.js 생성let auth = (req, res, next) =&amp;gt; { // 각종 인증 처리를 진행한다.}module.exports = { auth };auth.jsconst { User } = require(&quot;../models/User&quot;);let auth = (req, res, next) =&amp;gt; { // 각종 인증 처리를 진행한다. // 클라이언트 쿠키에서 토큰을 가져온다. let token = req.cookies.x_auth; // 토큰을 복호화한 후, 유저를 찾는다. User.findByToken(token, (err, user) =&amp;gt; { if (err) throw err; if (!user) return res.json({ isAuth: false, error: true }) req.token = token; req.user = user; next() // next가 없으면 middleware에 갇히니 주의한다! }) // 유저가 있으면 인증 OK // 유저가 없으면 인증 NO!}module.exports = { auth };User.jsuserSchema.statics.findByToken = function(token, cb) { var user = this; // 토큰을 decode 한다. // user._id + &#39;&#39; = token jwt.verify(token, &#39;secretToken&#39;, function(err, decoded) { // 유저 아이디를 이용하여 유저를 찾은 후, // 클라이언트에서 가져온 token과 DB에 보관된 token이 일치하는지 확인한다. user.findOne({ &quot;_id&quot; : decoded, &quot;token&quot;: token }, function(err, user) { if (err) return cb(err) cd(null, user) }) })}index.jsconst { auth } = require(&#39;./middleware/auth&#39;)// ...app.get(&#39;/api/users/auth&#39;, auth, (req, res) =&amp;gt; { // 여기까지 미들웨어를 통과해 왔다 =&amp;gt; Authentication이 true라는 뜻 res.status(200).json({ _id: req.user._id, isAdmin: req.user.role === 0 ? false : true, isAuth: true, email: req.user.email, name: req.user.name, lastName: req.user.lastName, role: req.user.role, image: req.user.image })})로그아웃 기능 로그아웃 Route를 만들어서, 로그아웃 하려는 유저를 DB에서 찾아서 그 유저의 토큰을 지워 준다. Auth를 구현할 때 클라이언트단에 있는 토큰과 DB에 있는 토큰을 비교하는데, DB에 있는 토큰을 지워 버리면 토큰 비교는 항상 실패하게 될 것이다. 따라서 로그아웃 시 DB의 토큰을 지우면 된다.app.get(&#39;/api/users/logout&#39;, auth, (req, res) =&amp;gt; { User.findOneAndUpdate({ _id: req.user._id }, { token: &quot;&quot;}, (err, user) =&amp;gt; { if (err) return res.json({ success: false, err}); return res.status(200).send({ success: true }) })}) 로그아웃 성공 후, DB의 토큰이 사라져 있다.해당 포스트는 다음의 강의를 수강하며 개인 기록용으로 메모하였습니다. 양질의 지식을 제공해 주신 John Ahn 님께 감사드립니다.따라하며 배우는 노드, 리액트 시리즈 - 기본 강의" } ]
